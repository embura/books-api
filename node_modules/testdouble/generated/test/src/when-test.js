// Generated by CoffeeScript 1.11.1
(function() {
  describe('when', function() {
    Given(function() {
      return this.testDouble = td["function"]();
    });
    describe('no-arg stubbing', function() {
      context('foo', function() {
        Given(function() {
          return td.when(this.testDouble()).thenReturn("foo");
        });
        return Then(function() {
          return this.testDouble() === "foo";
        });
      });
      return context('bar', function() {
        Given(function() {
          return td.when(this.testDouble()).thenReturn("bar");
        });
        return Then(function() {
          return this.testDouble() === "bar";
        });
      });
    });
    describe('last-in-wins overwriting', function() {
      Given(function() {
        return td.when(this.testDouble("something")).thenReturn("gold");
      });
      Given(function() {
        return td.when(this.testDouble("something")).thenReturn("iron");
      });
      return Then(function() {
        return this.testDouble("something") === "iron";
      });
    });
    describe('conditional stubbing', function() {
      Given(function() {
        return td.when(this.testDouble(1)).thenReturn("foo");
      });
      Given(function() {
        return td.when(this.testDouble(2)).thenReturn("bar");
      });
      Given(function() {
        return td.when(this.testDouble({
          lol: 'cheese'
        })).thenReturn('nom');
      });
      Given(function() {
        return td.when(this.testDouble({
          lol: 'fungus'
        })).thenReturn('eww');
      });
      Given(function() {
        return td.when(this.testDouble({
          lol: 'fungus'
        }, 2)).thenReturn('eww2');
      });
      Then(function() {
        return this.testDouble() === void 0;
      });
      And(function() {
        return this.testDouble(1) === "foo";
      });
      And(function() {
        return this.testDouble(2) === "bar";
      });
      And(function() {
        return this.testDouble({
          lol: 'cheese'
        }) === "nom";
      });
      And(function() {
        return this.testDouble({
          lol: 'fungus'
        }) === "eww";
      });
      return And(function() {
        return this.testDouble({
          lol: 'fungus'
        }, 2) === "eww2";
      });
    });
    describe('multiple test doubles', function() {
      Given(function() {
        return this.td1 = td.when(td["function"]()()).thenReturn("lol1");
      });
      Given(function() {
        return this.td2 = td.when(td["function"]()()).thenReturn("lol2");
      });
      Then(function() {
        return this.td1() === "lol1";
      });
      return Then(function() {
        return this.td2() === "lol2";
      });
    });
    describe('using matchers', function() {
      Given(function() {
        return td.when(this.testDouble(88, td.matchers.isA(Number))).thenReturn("yay");
      });
      Then(function() {
        return this.testDouble(88, 5) === "yay";
      });
      Then(function() {
        return this.testDouble(44, 5) === void 0;
      });
      return Then(function() {
        return this.testDouble(88, "five") === void 0;
      });
    });
    describe('stubbing sequential returns', function() {
      context('a single stubbing', function() {
        Given(function() {
          return td.when(this.testDouble()).thenReturn(10, 9);
        });
        When(function() {
          var ref;
          return ref = [this.testDouble(), this.testDouble(), this.testDouble()], this.first = ref[0], this.second = ref[1], this.third = ref[2], ref;
        });
        Then(function() {
          return this.first === 10;
        });
        Then(function() {
          return this.second === 9;
        });
        return Then(function() {
          return this.third === 9;
        });
      });
      return context('two overlapping stubbings', function() {
        Given(function() {
          return td.when(this.testDouble()).thenReturn('A');
        });
        Given(function() {
          return this.testDouble();
        });
        Given(function() {
          return td.when(this.testDouble()).thenReturn('B', 'C');
        });
        return Then(function() {
          return this.testDouble() === 'B';
        });
      });
    });
    describe('stubbing actions with `thenDo` instead of `thenReturn`', function() {
      Given(function() {
        return this.someAction = td.when(td["function"]()(55)).thenReturn('yatta');
      });
      Given(function() {
        return td.when(this.testDouble(55)).thenDo(this.someAction);
      });
      When(function() {
        return this.result = this.testDouble(55);
      });
      return And(function() {
        return this.result === 'yatta';
      });
    });
    describe('stubbing actions with `thenThrow` instead of `thenReturn`', function() {
      Given(function() {
        return this.error = new Error('lol');
      });
      Given(function() {
        return td.when(this.testDouble(42)).thenThrow(this.error);
      });
      When(function() {
        var e;
        try {
          return this.testDouble(42);
        } catch (error) {
          e = error;
          return this.result = e;
        }
      });
      return Then(function() {
        return this.error === this.result;
      });
    });
    describe('stubbing promises', function() {
      context('with a native promise', function() {
        if (typeof Promise !== 'function') {
          return;
        }
        describe('td.when…thenResolve', function() {
          Given(function() {
            return td.when(this.testDouble(10)).thenResolve('pants');
          });
          When(function(done) {
            return this.testDouble(10).then((function(_this) {
              return function(resolved) {
                _this.resolved = resolved;
                return done();
              };
            })(this));
          });
          return Then(function() {
            return this.resolved === 'pants';
          });
        });
        return describe('td.when…thenReject', function() {
          Given(function() {
            return td.when(this.testDouble(10)).thenReject('oops');
          });
          When(function(done) {
            return this.testDouble(10).then(null, (function(_this) {
              return function(rejected) {
                _this.rejected = rejected;
                return done();
              };
            })(this));
          });
          return Then(function() {
            return this.rejected === 'oops';
          });
        });
      });
      context('with an alternative promise constructor', function() {
        var FakePromise;
        FakePromise = (function() {
          function FakePromise(executor) {
            executor(((function(_this) {
              return function(resolved) {
                _this.resolved = resolved;
              };
            })(this)), ((function(_this) {
              return function(rejected) {
                _this.rejected = rejected;
              };
            })(this)));
          }

          FakePromise.prototype.then = function(success, failure) {
            if (this.resolved != null) {
              return success(this.resolved + '!');
            } else {
              return failure(this.rejected + '?');
            }
          };

          return FakePromise;

        })();
        Given(function() {
          return td.config({
            promiseConstructor: FakePromise
          });
        });
        describe('td.when…thenResolve', function() {
          Given(function() {
            return td.when(this.testDouble(10)).thenResolve('pants');
          });
          When(function(done) {
            return this.testDouble(10).then((function(_this) {
              return function(resolved) {
                _this.resolved = resolved;
                return done();
              };
            })(this));
          });
          return Then(function() {
            return this.resolved === 'pants!';
          });
        });
        return describe('td.when…thenReject', function() {
          Given(function() {
            return td.when(this.testDouble(10)).thenReject('oops');
          });
          When(function(done) {
            return this.testDouble(10).then(null, (function(_this) {
              return function(rejected) {
                _this.rejected = rejected;
                return done();
              };
            })(this));
          });
          return Then(function() {
            return this.rejected === 'oops?';
          });
        });
      });
      return context('with no promise constructor', function() {
        Given(function() {
          return this.warnings = [];
        });
        Given(function() {
          return this.errors = [];
        });
        Given(function() {
          return console.warn = (function(_this) {
            return function(m) {
              return _this.warnings.push(m);
            };
          })(this);
        });
        Given(function() {
          return console.error = (function(_this) {
            return function(m) {
              return _this.errors.push(m);
            };
          })(this);
        });
        Given(function() {
          return td.config({
            promiseConstructor: void 0
          });
        });
        return describe('td.when…thenResolve', function() {
          Given(function() {
            return td.when(this.testDouble(10)).thenResolve('pants');
          });
          Then(function() {
            return this.warnings[0] === "Warning: testdouble.js - td.when - no promise constructor is set, so this `thenResolve` or `thenReject` stubbing\nwill fail if it's satisfied by an invocation on the test double. You can tell\ntestdouble.js which promise constructor to use with `td.config`, like so:\n\n  td.config({\n    promiseConstructor: require('bluebird')\n  })";
          });
          return describe('actually invoking it', function() {
            When(function() {
              var e;
              try {
                return this.testDouble(10);
              } catch (error) {
                e = error;
                return this.error = e;
              }
            });
            return Then(function() {
              return this.error.message === "Error: testdouble.js - td.when - no promise constructor is set (perhaps this runtime lacks a native Promise\nfunction?), which means this stubbing can't return a promise to your\nsubject under test, resulting in this error. To resolve the issue, set\na promise constructor with `td.config`, like this:\n\n  td.config({\n    promiseConstructor: require('bluebird')\n  })";
            });
          });
        });
      });
    });
    describe('stubbing error, no invocation found', function() {
      Given(function() {
        return td.reset();
      });
      Given(function() {
        var e;
        try {
          return td.when().thenReturn('hi');
        } catch (error) {
          e = error;
          return this.error = e;
        }
      });
      return Then(function() {
        return this.error.message === "Error: testdouble.js - td.when - No test double invocation call detected for `when()`.\n\n  Usage:\n    when(myTestDouble('foo')).thenReturn('bar')";
      });
    });
    describe('config object', function() {
      describe('ignoring extra arguments', function() {
        context('for a no-arg stubbing', function() {
          Given(function() {
            return td.when(this.testDouble(), {
              ignoreExtraArgs: true
            }).thenReturn('pewpew');
          });
          When(function() {
            return this.result = this.testDouble('so', 'many', 'args');
          });
          return Then(function() {
            return this.result === 'pewpew';
          });
        });
        return context('when an initial-arg-matters', function() {
          Given(function() {
            return td.when(this.testDouble('important'), {
              ignoreExtraArgs: true
            }).thenReturn('neat');
          });
          context('satisfied without extra args', function() {
            return Then(function() {
              return this.testDouble('important') === 'neat';
            });
          });
          context('satisfied with extra args', function() {
            return Then(function() {
              return this.testDouble('important', 'not important') === 'neat';
            });
          });
          context('unsatisfied with no args', function() {
            return Then(function() {
              return this.testDouble() === void 0;
            });
          });
          return context('unsatisfied with extra args', function() {
            return Then(function() {
              return this.testDouble('unimportant', 'not important') === void 0;
            });
          });
        });
      });
      return describe('limiting times stubbing will work', function() {
        context('a single stub', function() {
          Given(function() {
            return td.when(this.testDouble(), {
              times: 2
            }).thenReturn('pants');
          });
          When(function() {
            return this.result = [this.testDouble(), this.testDouble(), this.testDouble()];
          });
          return Then(function() {
            return expect(this.result).to.deep.equal(['pants', 'pants', void 0]);
          });
        });
        return context('two overlapping stubbings', function() {
          Given(function() {
            return td.when(this.testDouble()).thenReturn('NO');
          });
          Given(function() {
            return td.when(this.testDouble(), {
              times: 1
            }).thenReturn('YES');
          });
          When(function() {
            return this.result = [this.testDouble(), this.testDouble(), this.testDouble()];
          });
          return Then(function() {
            return expect(this.result).to.deep.equal(['YES', 'NO', 'NO']);
          });
        });
      });
    });
    return describe('nested whens', function() {
      Given(function() {
        return this.knob = td["function"]();
      });
      Given(function() {
        return this.door = td["function"]();
      });
      Given(function() {
        return td.when(this.knob('twist')).thenReturn({
          door: td.when(this.door('push')).thenReturn('open')
        });
      });
      When(function() {
        return this.result = this.knob('twist').door('push');
      });
      return Then(function() {
        return this.result === 'open';
      });
    });
  });

}).call(this);
