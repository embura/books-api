// Generated by CoffeeScript 1.11.1
(function() {
  var _, addStubbing, callback, calls, concatImpliedCallback, log, stubbings, tdConfig, warnIfPromiseless,
    slice = [].slice;

  _ = require('./util/lodash-wrap');

  calls = require('./store/calls');

  stubbings = require('./store/stubbings');

  callback = require('./matchers/callback');

  log = require('./log');

  tdConfig = require('./config');

  module.exports = function(__userDoesPretendInvocationHere__, config) {
    if (config == null) {
      config = {};
    }
    return {
      thenReturn: function() {
        var stubbedValues;
        stubbedValues = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return addStubbing(stubbedValues, config, 'thenReturn');
      },
      thenCallback: function() {
        var stubbedValues;
        stubbedValues = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return addStubbing(stubbedValues, config, 'thenCallback');
      },
      thenDo: function() {
        var stubbedValues;
        stubbedValues = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return addStubbing(stubbedValues, config, 'thenDo');
      },
      thenThrow: function() {
        var stubbedValues;
        stubbedValues = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return addStubbing(stubbedValues, config, 'thenThrow');
      },
      thenResolve: function() {
        var stubbedValues;
        stubbedValues = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        warnIfPromiseless();
        return addStubbing(stubbedValues, config, 'thenResolve');
      },
      thenReject: function() {
        var stubbedValues;
        stubbedValues = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        warnIfPromiseless();
        return addStubbing(stubbedValues, config, 'thenReject');
      }
    };
  };

  addStubbing = function(stubbedValues, config, plan) {
    var last;
    _.assign(config, {
      plan: plan
    });
    if (last = calls.pop()) {
      stubbings.add(last.testDouble, concatImpliedCallback(last.args, config), stubbedValues, config);
      return last.testDouble;
    } else {
      return log.error("td.when", "No test double invocation call detected for `when()`.\n\n  Usage:\n    when(myTestDouble('foo')).thenReturn('bar')");
    }
  };

  concatImpliedCallback = function(args, config) {
    if (config.plan !== 'thenCallback') {
      return args;
    }
    if (!_.some(args, callback.isCallback)) {
      return args.concat(callback);
    } else {
      return args;
    }
  };

  warnIfPromiseless = function() {
    if (tdConfig().promiseConstructor != null) {
      return;
    }
    return log.warn("td.when", "no promise constructor is set, so this `thenResolve` or `thenReject` stubbing\nwill fail if it's satisfied by an invocation on the test double. You can tell\ntestdouble.js which promise constructor to use with `td.config`, like so:\n\n  td.config({\n    promiseConstructor: require('bluebird')\n  })");
  };

}).call(this);
