// Generated by CoffeeScript 1.11.1
(function() {
  var _, argsMatch, callback, callsStore, config, ensurePromise, executePlan, hasTimesRemaining, invokeCallbackFor, isSatisfied, log, store, stubbedValueFor, stubbingFor;

  _ = require('../util/lodash-wrap');

  store = require('./index');

  callsStore = require('./calls');

  argsMatch = require('../args-match');

  callback = require('../matchers/callback');

  config = require('../config');

  log = require('../log');

  module.exports = {
    add: function(testDouble, args, stubbedValues, config) {
      return store["for"](testDouble).stubbings.push({
        callCount: 0,
        stubbedValues: stubbedValues,
        args: args,
        config: config
      });
    },
    invoke: function(testDouble, actualArgs) {
      var stubbing;
      if (!(stubbing = stubbingFor(testDouble, actualArgs))) {
        return;
      }
      return executePlan(stubbing, actualArgs);
    },
    "for": function(testDouble) {
      return store["for"](testDouble).stubbings;
    }
  };

  stubbingFor = function(testDouble, actualArgs) {
    return _.findLast(store["for"](testDouble).stubbings, function(stubbing) {
      return isSatisfied(stubbing, actualArgs);
    });
  };

  executePlan = function(stubbing, actualArgs) {
    var Promise, value;
    Promise = config().promiseConstructor;
    value = stubbedValueFor(stubbing);
    stubbing.callCount += 1;
    invokeCallbackFor(stubbing, actualArgs);
    switch (stubbing.config.plan) {
      case "thenReturn":
        return value;
      case "thenDo":
        return value.apply(null, actualArgs);
      case "thenThrow":
        throw value;
        break;
      case "thenResolve":
        ensurePromise(Promise);
        return new Promise(function(resolve) {
          return resolve(value);
        });
      case "thenReject":
        ensurePromise(Promise);
        return new Promise(function(resolve, reject) {
          return reject(value);
        });
    }
  };

  invokeCallbackFor = function(stubbing, actualArgs) {
    if (!_.some(stubbing.args, callback.isCallback)) {
      return;
    }
    return _.each(stubbing.args, function(expectedArg, i) {
      var callbackArgs;
      if (!callback.isCallback(expectedArg)) {
        return;
      }
      callbackArgs = expectedArg.args != null ? expectedArg.args : stubbing.config.plan === 'thenCallback' ? stubbing.stubbedValues : [];
      return actualArgs[i].apply(actualArgs, callbackArgs);
    });
  };

  stubbedValueFor = function(stubbing) {
    if (stubbing.callCount < stubbing.stubbedValues.length) {
      return stubbing.stubbedValues[stubbing.callCount];
    } else {
      return _.last(stubbing.stubbedValues);
    }
  };

  isSatisfied = function(stubbing, actualArgs) {
    return argsMatch(stubbing.args, actualArgs, stubbing.config) && hasTimesRemaining(stubbing);
  };

  hasTimesRemaining = function(stubbing) {
    if (stubbing.config.times == null) {
      return true;
    }
    return stubbing.callCount < stubbing.config.times;
  };

  ensurePromise = function(Promise) {
    if (Promise != null) {
      return;
    }
    return log.error("td.when", "no promise constructor is set (perhaps this runtime lacks a native Promise\nfunction?), which means this stubbing can't return a promise to your\nsubject under test, resulting in this error. To resolve the issue, set\na promise constructor with `td.config`, like this:\n\n  td.config({\n    promiseConstructor: require('bluebird')\n  })");
  };

}).call(this);
